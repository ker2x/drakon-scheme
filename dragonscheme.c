/* Autogenerated with DRAKON Editor 1.14 */
#include "dragonscheme.h"

object *the_empty_list;
object *false;
object *true;

object *read(FILE *in);
void write(object *obj);

#define BUFFER_MAX 1000
#define caar(obj)   car(car(obj))
#define cadr(obj)   car(cdr(obj))
#define cdar(obj)   cdr(car(obj))
#define cddr(obj)   cdr(cdr(obj))
#define caaar(obj)  car(car(car(obj)))
#define caadr(obj)  car(car(cdr(obj)))
#define cadar(obj)  car(cdr(car(obj)))
#define caddr(obj)  car(cdr(cdr(obj)))
#define cdaar(obj)  cdr(car(car(obj)))
#define cdadr(obj)  cdr(car(cdr(obj)))
#define cddar(obj)  cdr(cdr(car(obj)))
#define cdddr(obj)  cdr(cdr(cdr(obj)))
#define caaaar(obj) car(car(car(car(obj))))
#define caaadr(obj) car(car(car(cdr(obj))))
#define caadar(obj) car(car(cdr(car(obj))))
#define caaddr(obj) car(car(cdr(cdr(obj))))
#define cadaar(obj) car(cdr(car(car(obj))))
#define cadadr(obj) car(cdr(car(cdr(obj))))
#define caddar(obj) car(cdr(cdr(car(obj))))
#define cadddr(obj) car(cdr(cdr(cdr(obj))))
#define cdaaar(obj) cdr(car(car(car(obj))))
#define cdaadr(obj) cdr(car(car(cdr(obj))))
#define cdadar(obj) cdr(car(cdr(car(obj))))
#define cdaddr(obj) cdr(car(cdr(cdr(obj))))
#define cddaar(obj) cdr(cdr(car(car(obj))))
#define cddadr(obj) cdr(cdr(car(cdr(obj))))
#define cdddar(obj) cdr(cdr(cdr(car(obj))))
#define cddddr(obj) cdr(cdr(cdr(cdr(obj))))
object* alloc_object(
    void
) {
    // item 187
    object *obj;
    /* item 188 */
    obj = malloc(sizeof(object));
    
    // item 189
    if (obj == NULL) {
        /* item 192 */
        fprintf(stderr, "out of memory\n");
        /* item 193 */
        exit(1);
        return;
    } else {
        /* item 194 */
        return obj;
    }
    
}

object* car(
    object* pair
) {
    // item 480
    return pair->data.pair.car;
    
}

object* cdr(
    object *pair
) {
    // item 492
    return pair->data.pair.cdr;
    
}

object* cons(
    object* car,
    object* cdr
) {
    // item 466
    object *obj;
    /* item 467 */
    obj = alloc_object();
    obj->type = PAIR;
    obj->data.pair.car = car;
    obj->data.pair.cdr = cdr;
    /* item 468 */
    return obj;
    
}

void eat_expected_string(
    FILE *in,
    char *str
) {
    // item 277
    int c;
    
    item_278 :
    if (*str == '\0') {
        return;
    } else {
        /* item 280 */
        c = getc(in);
    }
    
    // item 281
    if (c == *str) {
        /* item 286 */
        str++;
        goto item_278;
    } else {
        /* item 284 */
        fprintf(stderr, 
        "unexpected character '%c'\n", c);
        /* item 285 */
        exit(1);
        return;
    }
    
}

void eat_whitespace(
    FILE *in
) {
    // item 126
    int c;
    
    item_130 :
    c = getc(in);
    
    // item 127
    if (c == EOF) {
        goto item_145;
    } else {
    }
    
    // item 131
    if (isspace(c)) {
        goto item_130;
    } else {
    }
    
    // item 133
    if (c == ';') {
    } else {
        goto item_145;
    }
    
    item_138 :
    c = getc(in);
    
    // item 136
    if ((c == EOF) || ((c == '\n'))) {
    } else {
        goto item_138;
    }
    
    item_145 :
    ungetc(c, in);
    return;
    
}

object* eval(
    object *exp
) {
    // item 49
    return exp;
    
}

void init(
    void
) {
    // item 218
    false = alloc_object();
    false->type = BOOLEAN;
    false->data.boolean.value = 0;
    /* item 219 */
    true = alloc_object();
    true->type = BOOLEAN;
    true->data.boolean.value = 1;
    /* item 459 */
    the_empty_list = alloc_object();
    the_empty_list->type = THE_EMPTY_LIST;
    return;
    
}

char is_boolean(
    object *obj
) {
    // item 200
    return obj->type == BOOLEAN;
    
}

char is_character(
    object *obj
) {
    // item 271
    return obj->type == CHARACTER;
    
}

char is_delimiter(
    int c
) {
    // item 167
    return isspace(c) || c == EOF ||
               c == '('   || c == ')' ||
               c == '"'   || c == ';';
    
}

char is_false(
    object *obj
) {
    // item 206
    return obj == false;
    
}

char is_fixnum(
    object *obj
) {
    // item 173
    return obj->type == FIXNUM;
    
}

char is_pair(
    object* obj
) {
    // item 474
    return obj->type == PAIR;
    
}

char is_string(
    object *obj
) {
    // item 378
    return obj->type == STRING;
    
}

char is_the_empty_list(
    object *obj
) {
    // item 440
    return obj == the_empty_list;
    
}

char is_true(
    object *obj
) {
    // item 212
    return !is_false(obj);
    
}

void main(
    void
) {
    // item 15
    printf("Welcome to Bootstrap Scheme. " 
    "Use ctrl-c to exit.\n");
    /* item 252 */
    init();
    
    item_19 :
    printf("> ");
    /* item 18 */
    write(eval(read(stdin)));
    /* item 20 */
    printf("\n");
    
    // item 21
    if (1) {
        goto item_19;
    } else {
        return;
    }
    
}

object* make_character(
    char value
) {
    // item 263
    object *obj;
    /* item 264 */
    obj = alloc_object();
    obj->type = CHARACTER;
    obj->data.character.value = value;
    /* item 265 */
    return obj;
    
}

object* make_fixnum(
    long value
) {
    // item 179
    object *obj;
    /* item 180 */
    obj = alloc_object();
    obj->type = FIXNUM;
    obj->data.fixnum.value = value;
    /* item 181 */
    return obj;
    
}

object* make_string(
    char* value
) {
    // item 364
    object *obj;
    /* item 365 */
    obj = alloc_object();
    obj->type = STRING;
    obj->data.string.value = malloc(strlen(value) + 1);
    
    // item 366
    if (obj->data.string.value == NULL) {
        /* item 369 */
        fprintf(stderr, "out of memory\n");
        /* item 370 */
        exit(1);
    } else {
    }
    
    // item 371
    strcpy(obj->data.string.value, value);
    /* item 372 */
    return obj;
    
}

int peek(
    FILE *in
) {
    // item 158
    int c;
    /* item 159 */
    c = getc(in);
    /* item 160 */
    ungetc(c,in);
    /* item 161 */
    return c;
    
}

void peek_expected_delimiter(
    FILE *in
) {
    // item 296
    if (is_delimiter(peek(in))) {
        return;
    } else {
        /* item 299 */
        fprintf(stderr, "character not followed by delimiter\n");
        /* item 300 */
        exit(1);
        return;
    }
    
}

object* read(
    FILE *in
) {
    // item 78
    int c;
    short sign = 1;
    long num = 0;
    char buffer[BUFFER_MAX];
    int i;
    /* item 79 */
    eat_whitespace(in);
    /* item 80 */
    c = getc(in);
    
    // item 227
    if (c == '#') {
        /* item 230 */
        c = getc(in);
    } else {
        goto item_84;
    }
    
    // item 2310001
    if (c == 't') {
        /* item 238 */
        return true;
        goto item_91;
    } else {
    }
    
    // item 2310002
    if (c == 'f') {
        /* item 239 */
        return false;
        goto item_91;
    } else {
    }
    
    // item 2310003
    if (c == '\\') {
        /* item 342 */
        return read_character(in);
        goto item_91;
    } else {
        /* item 241 */
        fprintf(stderr, 
        "unknown boolean literal\n");
        goto item_91;
    }
    
    item_84 :
    if (isdigit(c)) {
        /* item 93 */
        ungetc(c, in);
        goto item_100;
    } else {
    }
    
    // item 87
    if ((c == '-' && (isdigit(peek(in))))) {
        /* item 92 */
        sign = -1;
    } else {
        goto item_379;
    }
    
    item_100 :
    if (isdigit(c = getc(in))) {
        /* item 101 */
        num = (num * 10) + (c - '0');
        goto item_100;
    } else {
        /* item 104 */
        num *= sign;
    }
    
    // item 105
    if (is_delimiter(c)) {
        /* item 108 */
        ungetc(c, in);
        /* item 109 */
        return make_fixnum(num);
        goto item_91;
    } else {
        /* item 111 */
        fprintf(stderr, 
        "number not followed by delimiter\n");
        goto item_91;
    }
    
    item_379 :
    if (c == '"') {
        /* item 382 */
        i = 0;
    } else {
        goto item_444;
    }
    
    item_385 :
    c = getc(in);
    
    // item 386
    if (c == '"') {
        /* item 408 */
        buffer[i] = '\0';
        return make_string(buffer);
        goto item_91;
    } else {
    }
    
    // item 387
    if (c == '\\') {
        /* item 389 */
        c = getc(in);
    } else {
        goto item_395;
    }
    
    // item 391
    if (c == 'n') {
        /* item 394 */
        c = '\n';
    } else {
    }
    
    item_395 :
    if (c == EOF) {
        /* item 396 */
        fprintf(stderr, 
        "non-terminated string literal\n");
        /* item 398 */
        exit(1);
    } else {
    }
    
    // item 401
    if (i < BUFFER_MAX - 1) {
        /* item 402 */
        buffer[i++] = c;
        goto item_385;
    } else {
        /* item 404 */
        fprintf(stderr, 
        "string too long. Maximum length is %d\n",
        BUFFER_MAX);
        /* item 405 */
        exit(1);
        goto item_385;
    }
    
    item_444 :
    if (c == '(') {
        /* item 578 */
        return read_pair(in);
    } else {
        /* item 453 */
        fprintf(stderr, "unexpected character '%c'. "
        "Expecting ')'\n", c);
        /* item 454 */
        exit(1);
    }
    
    item_91 :
    exit(1);
    return;
    
}

object* read_character(
    FILE *in
) {
    // item 306
    int c;
    /* item 307 */
    c = getc(in);
    
    // item 3080001
    if (c == EOF) {
        /* item 315 */
        fprintf(stderr, "incomplete character literal\n");
        /* item 330 */
        exit(1);
        goto item_329;
    } else {
    }
    
    // item 3080002
    if (c == 's') {
    } else {
        goto item_3080003;
    }
    
    // item 316
    if (peek(in) == 'p') {
        /* item 319 */
        eat_expected_string(in, "pace");
        /* item 320 */
        peek_expected_delimiter(in);
        /* item 321 */
        return make_character(' ');
        goto item_329;
    } else {
        goto item_329;
    }
    
    item_3080003 :
    if ((c == 'n') && (peek(in) == 'e')) {
        /* item 324 */
        eat_expected_string(in, "ewline");
        /* item 325 */
        peek_expected_delimiter(in);
        /* item 326 */
        return make_character('\n');
    } else {
    }
    
    item_329 :
    peek_expected_delimiter(in);
    /* item 328 */
    return make_character(c);
    
}

object* read_pair(
    FILE *in
) {
    // item 543
    int c;
    object *car_obj;
    object *cdr_obj;
    /* item 544 */
    eat_whitespace(in);
    c = getc(in);
    
    // item 545
    if (c == ')') {
        /* item 548 */
        return the_empty_list;
    } else {
        /* item 549 */
        ungetc(c, in);
        car_obj = read(in);
        eat_whitespace(in);
        c = getc(in);
    }
    
    // item 550
    if (c == '.') {
        /* item 552 */
        c = peek(in);
    } else {
        /* item 568 */
        ungetc(c, in);
        cdr_obj = read_pair(in);        
        return cons(car_obj, cdr_obj);
    }
    
    // item 553
    if (is_delimiter(c)) {
        /* item 557 */
        cdr_obj = read(in);
        eat_whitespace(in);
        c = getc(in);
    } else {
        /* item 555 */
        fprintf(stderr, 
        "dot not followed by delimiter\n");
        /* item 556 */
        exit(1);
        return;
    }
    
    // item 569
    if (c == ')') {
        /* item 575 */
        return cons(car_obj, cdr_obj);
    } else {
        /* item 572 */
        fprintf(stderr,
        "where was the trailing right paren?\n");
        /* item 573 */
        exit(1);
        return;
    }
    
}

void set_car(
    object* obj,
    object* value
) {
    // item 486
    obj->data.pair.car = value;
    return;
    
}

void set_cdr(
    object* obj,
    object* value
) {
    // item 498
    obj->data.pair.cdr = value;
    return;
    
}

void write(
    object* obj
) {
    int _sw290000_ = 0;
    int _sw4190000_ = 0;
    // item 358
    char c;
    char *str;
    /* item 290000 */
    _sw290000_ = obj->type;
    
    // item 290001
    if (_sw290000_ == FIXNUM) {
        /* item 35 */
        printf("%ld", obj->data.fixnum.value);
        return;
    } else {
    }
    
    // item 290002
    if (_sw290000_ == BOOLEAN) {
        /* item 223 */
        printf("#%c", is_false(obj) ? 'f' : 't');
        return;
    } else {
    }
    
    // item 290003
    if (_sw290000_ == CHARACTER) {
        /* item 347 */
        c = obj->data.character.value;
    } else {
        goto item_290004;
    }
    
    // item 3480001
    if (c == '\n') {
        /* item 355 */
        printf("newline");
        return;
    } else {
    }
    
    // item 3480002
    if (c == ' ') {
        /* item 356 */
        printf("space");
        return;
    } else {
        /* item 357 */
        putchar(c);
        return;
    }
    
    item_290004 :
    if (_sw290000_ == STRING) {
        /* item 413 */
        str = obj->data.string.value;
        /* item 414 */
        putchar('"');
    } else {
        goto item_290005;
    }
    
    item_415 :
    if (*str == '\0') {
        /* item 434 */
        putchar('"');
        return;
    } else {
        /* item 4190000 */
        _sw4190000_ = *str;
    }
    
    // item 4190001
    if (_sw4190000_ == '\n') {
        /* item 427 */
        printf("\\n");
        goto item_418;
    } else {
    }
    
    // item 4190002
    if (_sw4190000_ == '\\') {
        /* item 428 */
        printf("\\\\");
        goto item_418;
    } else {
    }
    
    // item 4190003
    if (_sw4190000_ == '"') {
        /* item 429 */
        printf("\\\"");
    } else {
        /* item 432 */
        putchar(*str);
    }
    
    item_418 :
    str++;
    goto item_415;
    
    item_290005 :
    if (_sw290000_ == THE_EMPTY_LIST) {
        /* item 457 */
        printf("()");
        return;
    } else {
    }
    
    // item 290006
    if (_sw290000_ == PAIR) {
        /* item 582 */
        printf("(");
        write_pair(obj);
        printf(")");
        return;
    } else {
        /* item 37 */
        fprintf(stderr, "cannot write unknown type\n");
        /* item 38 */
        exit(1);
        return;
    }
    
}

void write_pair(
    object* pair
) {
    // item 588
    object *car_obj;
    object *cdr_obj;
        
    car_obj = car(pair);
    cdr_obj = cdr(pair);
    write(car_obj);
    
    // item 589
    if (cdr_obj->type == PAIR) {
        /* item 592 */
        printf(" ");
        write_pair(cdr_obj);
        return;
    } else {
    }
    
    // item 593
    if (cdr_obj->type == THE_EMPTY_LIST) {
        return;
    } else {
        /* item 595 */
        printf(" . ");
        write(cdr_obj);
        return;
    }
    
}



